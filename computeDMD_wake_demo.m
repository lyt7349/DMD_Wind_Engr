%% Introduction 
% This computeDMD_wake_demo.m algorithm and sample data are based on the
% computeDMD.m algorithm from Kutz et al. (2016). To give full credit and
% for more details, readers shall refer to Chapter 2 of
% Kutz, J. N., Brunton, S. L., Brunton, B. W., & Proctor, J. L. (2016).
%   Dynamic Mode Decomposition: Data-Driven Modeling of Complex Systems. In
%   Society for Industrial and Applied Mathematics (Vol. 32, Issue 4).
%   Society for Industrial and Applied Mathematics.
%   https://doi.org/10.1137/1.9781611974508

% This pedagogical example demonstrates a Koopman analysis via the
% similarity-matrix Dynamic Mode Decomposition (DMD) on a prototypical wind
% engineering problem (though at significantly reduced Re for simplicity),
% the cylinder wake.
%
% Author: Cruz Y. Li
%% Step 0: Initialization
clearvars, close all, clc;

%% Step 1: Data Curation
tic
load CYLINDER_ALL.mat VORTALL nx ny
% CYLINDER_ALL.mat is generated by the IBPM code at
% https://github.com/cwrowley/ibpm
% and can be downloaded at http://www.dmdbook.com/
% Configuration: cylinder wake at Re=100
%                m=151 (5 vortex shedding cycles), deltaT=0.2.
%                St=0.16

% Mean-subtraction (Optional)
mean_sub = 1;               % 1: subtract mean; 0: original data
if mean_sub == 1
    VORTALL = VORTALL-mean(VORTALL,2);
    disp('Mean-subtraction: using mean subtracted data')
elseif mean_sub == 0
    disp('Mean-subtraction: using original data')
else
    disp('Mean-subtraction: invalid input, using original data')
end

% Matrix arrangement
X1 = VORTALL(:,1:end-1);        % Construct X1
X2 = VORTALL(:,2:end);          % Construct X2
dt = 0.2;                       % Uniform time step /deltat

disp('---Step 1: Data Curation--Complete---')
toc

%% Step 2: SVD
tic
[U,S,V] = svd(X1,'econ');       % Perform Singular-Value Decomposition

% Truncation by singular value (Optional)
trunc = 0;                      % 1: define order r; 0: full-order
               
if trunc == 1
    r = 21;                     % Define r
    disp(['Trucation: truncation order r=',num2str(r)])
elseif trunc == 0
    r = size(U,2);
    disp('Trucation: no truncation, full-order')
else
    disp('Trucation: invalid input, using full-order')
end

U_r = U(:,1:r);                % Spatial info (POD modes)
S_r = S(1:r,1:r);              % /Sigma (diag.) singular values (energy)
V_r = V(:,1:r);                % Temporal info (neglected by POD)

disp('---Step 2: SVD--Complete---')
toc

%% Step 3: Koopman Approximation
tic
Atilde = U_r'*X2*V_r/S_r;     % Derive similarity matrix A/tilde
                             % r-dim. approx. of Koopman operator

disp('---Step 3: Koopman Approximation--Complete---')
toc

%% Step 4: Eigen Decomposition
tic
[W_r,D] = eig(Atilde);       % Perform Eigen Decomposition on A/tilde
                             % W eigen vectors, D (diag.) eigen values

disp('---Step 4: Eigen Decomposition--Complete---')
toc

%% Step 5: DMD Mode
tic
Phi = X2*V_r/S_r*W_r;         % Calculate the exact DMD mode

disp('---Step 5: DMD Mode--Complete---')
toc

%% Step 6: Coefficient of Weight
tic
x1 = X1(:,1);                 % Extract initial conditions
alpha = Phi\x1;               % Calculate coefficient of weight

disp('---Step 6: Coefficient of Weight--Complete---')
toc


%% Step 7: Reconstruction & Growth Rate & Frequency
tic
% Reconstruction
rss = length(alpha);          % Number of mode selected for reconstr.
tr = size(X1,2);              % Time range to reconstruct

time_dynamics = zeros(rss,tr);% Initialize
t = (0:tr-1)*dt;              % Populate time sequence

lambda = diag(D);             % Discrete-time eigenvalues
omega = log(lambda)/dt;       % Continuous-time eigenvalues

% Iterative population of time dynamics
for iter = 1:tr
    time_dynamics(:,iter) = (alpha.*exp(omega*t(iter)));
end

Xdmd = Phi*time_dynamics;     % Caculate DMD reconst. data
eDMD = abs((X1-Xdmd)./(X1+1e-20))*.100;
eDMD_mean = zeros(1,size(X1,2));
eDMD_rms = zeros(1,size(X1,2));

for i=1:size(X1,2)
    eDMD_mean(i) = mean(eDMD(:,i));
    eDMD_rms(i) = rms(eDMD(:,i));
end

% Growth Rate
g = diag(real(log(D))./dt);   % Calculate growth rate

% Eigen Frequency
freq = diag(imag(log(D))./(dt*2*pi));   %Calculate eigen frequency (Hz)

disp('---Step 7: Reconstruction & Growth Rate & Frequency--Complete---')
toc
disp(['The max mean and rms reconstruction errors are ',...
    num2str(max(eDMD_mean)),' and ',num2str(max(eDMD_rms))])

%% Plot DMD modes
for i=1:2:10
    plotCylinder(reshape(real(Phi(:,i)),nx,ny),nx,ny);
    plotCylinder(reshape(imag(Phi(:,i)),nx,ny),nx,ny);
end
 
%%  Plot DMD spectrum
figure;
set(gcf,'Position',[50 50 600 600]);
theta = (0:1:100)*2*pi/100;
plot(cos(theta),sin(theta),'r--') % plot unit circle
hold on, grid on
scatter(real(diag(D)),imag(diag(D)),'ok')
axis([-1.05 1.05 -1.05 1.05]);
axis equal

function f1 = plotCylinder(VORT,ny,nx)

f1 = figure;

vortmin = -5;  % only plot what is in -5 to 5 range
vortmax = 5;
VORT(VORT>vortmax) = vortmax;  % cutoff at vortmax
VORT(VORT<vortmin) = vortmin;  % cutoff at vortmin

imagesc(VORT); % plot vorticity field 
colormap('jet');  % use custom colormap

% clean up axes
set(gca,'XTick',[1 50 100 150 200 250 300 350 400 449],'XTickLabel',{'-1','0','1','2','3','4','5','6','7','8'})
set(gca,'YTick',[1 50 100 150 199],'YTickLabel',{'2','1','0','-1','-2'});
set(gcf,'Position',[100 100 900 390])
axis equal
hold on

% add contour lines (positive = solid, negative = dotted)
contour(VORT,[-5.5:.5:-.5 -.25 -.125],':k','LineWidth',1.2)
contour(VORT,[.125 .25 .5:.5:5.5],'-k','LineWidth',1.2)

theta = (1:100)/100'*2*pi;
x = 49+25*sin(theta);
y = 99+25*cos(theta);
fill(x,y,[.3 .3 .3])  % place cylinder
plot(x,y,'k','LineWidth',1.2) % cylinder boundary

set(gcf,'PaperPositionMode','auto') % 
% print('-depsc2', '-loose', 'figures/cylinder'); % eps are vector images
% fix_lines('figures/cylinder.eps','figures/cylinder.eps') % fix dashed lines

end